
<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
        <title>QUELLE</title>
        <script type="text/javascript" src="http://d3js.org/d3.v3.js"></script>

        <style type="text/css">

            .node circle {
                cursor: pointer;
                fill: #fff;
                stroke: steelblue;
                stroke-width: 1.5px;
            }

            .node text {
                font: 10px sans-serif;
            }

            path.link {
                fill: none;
                stroke: #ccc;
                stroke-dasharray: 3.3;
                stroke-width: 1.5px;
            }

            path.metricLink {
                fill: none;
                stroke: #A31E39;
                stroke-width: 3px;
            }

            #A{
                position:absolute;
                top:50%;
                left:50%;
            }

            div.tooltip {   
                position: absolute;           
                text-align: center;           
                width: 60px;                  
                height: 28px;                 
                padding: 2px;             
                font: 12px sans-serif;        
                background: lightsteelblue;   
                border: 0px;      
                border-radius: 8px;           
                pointer-events: none;         
            }

        </style>
    </head>
    <body>
        <div id="A"></div>
        <div id="chart"></div>
        <div id="ManagementOptions">
            Management Pane:
        </div> 

        <div id="AddStrategyDiv" hidden>  
            <form action="#" id="AddStrategyForm" onsubmit="return processExecutingCommand(this)">
                Strategy: 
                <select name="strategyOption" id="strategyOptionSelect" form="AddStrategyForm" > 
                    <option value="OVERALL_ELASTICITY" >OVERALL_ELASTICITY</option>
                    <option value="COST_ELASTICITY" >COST_ELASTICITY</option>
                    <option value="QUALITY_ELASTICITY" >QUALITY_ELASTICITY</option>
                    <option value="RESOURCE_ELASTICITY" >RESOURCE_ELASTICITY</option>
                    <option value="SERVICE_UNITS_ASSOCIATIONS_ELASTICITY" >SERVICE_UNITS_ASSOCIATIONS_ELASTICITY</option>

                    <option value="OVERALL_REQUIREMENTS" >OVERALL_REQUIREMENTS</option>
                    <option value="COST_REQUIREMENTS" >COST_REQUIREMENTS</option>
                    <option value="QUALITY_REQUIREMENTS" >QUALITY_REQUIREMENTS</option>
                    <option value="RESOURCE_REQUIREMENTS" >RESOURCE_REQUIREMENTS</option>

                    <option value="MINIMUM_COST" >MINIMUM_COST</option>
                    <option value="MINIMUM_RESOURCES" >MINIMUM_RESOURCES;
                </select>
                <input type="text" name="data" id="AddStrategyFormData" hidden>
                <input type="submit">
            </form>
        </div> 

        <div id="AddStructureElementDiv" hidden>  
            <form action="#" id="AddStructureElementForm" onsubmit="return processExecutingCommand(this)">
                Name: <input type="text" name="elementName" id="elementName"> 
                <input type="text" name="data" id="AddStructureElementFormData" hidden>
                <input type="submit">
            </form>
        </div> 

        <div id="AddRequirementDiv" hidden>  
            <form action="#" id="AddRequirementForm" onsubmit="return processExecutingCommand(this)">
                Requirement metric type: 
                <select name="metricTypeSelect" id="metricTypeSelect" form="AddRequirementForm" > 
                    <option value="" selected></option>
                    <option value="COST">COST</option>
                    <option value="QUALITY" >QUALITY</option>
                    <option value="RESOURCE" >RESOURCE</option>
                </select>
                Requirement metric:
                <select name="requirementMetricsSelect" id="requirementMetricsSelect" form="AddRequirementForm" > 
                </select>
                <input type="text" name="data" id="AddRequirementFormData" hidden>
                <input type="submit">
            </form>
        </div> 

        <div id="AddConditionDiv" hidden>  
            <form action="#" id="AddConditionForm" onsubmit="return processExecutingCommand(this)">
                Condition: 
                <select name="conditionTypeSelect" id="conditionTypeSelect" form="AddConditionForm" > 
                    <option value="LESS_THAN" selected>LESS_THAN</option>
                    <option value="LESS_EQUAL">LESS_EQUAL</option>
                    <option value="GREATER_THAN" >GREATER_THAN</option>
                    <option value="GREATER_EQUAL" >GREATER_EQUAL</option>
                    <option value="EQUAL" >EQUAL</option>
                    <option value="RANGE" >RANGE</option>
                    <option value="ENUMERATION" >ENUMERATION</option>
                </select>
                <input type="text" name="conditionValue" id="conditionValue">
                <input type="text" name="data" id="AddConditionsFormData" hidden>
                <input type="submit">
            </form>
        </div> 

        <!--  <div id="ManagementOptionDiv">  
             <form action="#" id="UpdateRequirementsForm">
                 Select management option:
                 <input type="text" name="fname">
 
                 <select name="managementOption" id="managementOptionSelect" form="UpdateRequirementsForm" > 
                     <option value="manageStructure" selected>Manage Structure</option>
                     <option value="manageRequirements">Manage Requirements</option>
                 </select>
 
                 <input type="submit">
             </form>
         </div> 
         <div id="StructureManagementDiv"  >  
             <form action="#" id="UpdateStructureForm">
                 Managing structure of:
                 <input type="text" id ="managedElementID" readonly>
 
                 <br>
                 <input type="submit">
             </form>
         </div> -->

        <script src="./spin.js" type="text/javascript"></script>
        <script type="text/javascript">

                function contains(children, child) {
                    for (var index = 0; index < children.length; index++) {
                        if (children[index].name == child.name) {
                            return 0;
                        }
                    }
                    return -1;
                }

                function updateTextOnNode(node, new_root, change) {

                    if (node.actionName || new_root.actionName) {
                        //node.name = new_root.name + ": " + new_root.actionName;
                        node.attention = new_root.attention;
                        node.actionName = new_root.actionName;
                    }

                    node.name = new_root.name;
                    if (!node.children) {
                        node.children = [];
                    }


                    //check if some new nodes have appeared
                    if (node.children.length < new_root.children.length) {
                        //for all new children
                        for (var index = 0; index < new_root.children.length; index++) {
                            //if the children are not metrics
                            if (new_root.children[index].type.match(/SERVIC.*|V.*/g)) {
                                //if new root child DOES NOT ALLREADY EXIST
                                if (contains(node.children, new_root.children[index]) == -1) {
                                    node.children.push(new_root.children[index]);
                                    update(node);
                                    change = 0;
                                }
                            }
                        }
                    }

                    //check if nodes need to be removed
                    if (node.children.length > new_root.children.length) {
                        for (var index = 0; index < node.children.length; index++) {
                            if (node.children[index].type.match(/SERVIC.*|V.*/g)) {
                                if (contains(new_root.children, node.children[index]) == -1) {
                                    node.children.splice(index, 1);
                                    change = 0;
                                }
                            }
                        }
                    }

                    //remove all metrics, requirements and conditions so that they can be updated
                    for (var index = 0; index < node.children.length; index++) {
                        var oldEntry = node.children[index];
                        if (!oldEntry.type.match(/SERVIC.*|V.*/g)) {
                            node.children.splice(index, 1);
                            //start over
                            index = -1;
                        }
                    }


                    //add all new metrics so that they can be updated
                    for (var index = 0; index < new_root.children.length; index++) {
                        var newEntry = new_root.children[index];
                        if (!newEntry.type.match(/SERVIC.*|V.*/g)) {
                            node.children.push(newEntry);
                        }
                    }

                    //update all children not metrics
                    for (var index = 0; index < node.children.length; index++) {
                        var oldEntry = node.children[index];
                        if (oldEntry.type.match(/SERVIC.*|V.*/g)) {
                            //find the element int the new children that matches this
                            for (var indexNew = 0; indexNew < new_root.children.length; indexNew++) {
                                var newEntry = new_root.children[indexNew];
                                if (newEntry.type.match(/SERVIC.*|V.*/g)) {
                                    if (oldEntry.name == newEntry.name) {
                                        updateTextOnNode(oldEntry, newEntry);
                                    }
                                }
                            }
                        }
                    }

                }


                var selectedMetric;
                var simpleComponentIcon = "m 5,10 c 1.7265,0.251 5.7035,0.0355 4.8055,2.6145 -0.9305,2.0335 -3.066,3.827 0.214,4.8855 1.9925,0.6435 10.717,1.143 9.7905,-2.5835 -1.1255,-1.2255 -2.5535,-2.4125 -1.2315,-4.0245 2.8935,-0.552 5.8135,-0.9665 8.747,-1.2365 2.779,-0.2555 5.01138,-0.3785 7.80388,-0.3535 0,0 0.0342,-28.8233 0,-28.782 l -42.17988,0 c -0.7375,3.8525 -0.9175,8.9665 1.1535,10.61 3.0355,1.834 7.6995,-3.225 9.5015,0.7885 1.384,3.0825 -0.1075,8.324 -4.242,6.515 -4.9185,-2.1525 -7.189,0.88 -6.7055,6.19 0.1545,1.6955 0.472,3.214 0.701,4.702 3.891,-0.081 7.791,0.114 11.642,0.6745 z";
                var complexComponentIcon = "m -10,0 c 3.73224,-0.7459 8.66496,-0.9953 8.05062,0.63028 l -0.81288,2.33051 c 0.0832,1.10156 6.73944,1.38304 6.33894,-0.31885 0,0 -1.18264,-2.45972 -0.99342,-2.50527 -0.0569,-0.88313 8.32576,-0.86545 8.32576,-0.86545 0.78063,1.41974 -0.96421,4.29648 -0.50291,5.19887 1.09973,2.15125 4.95457,0.51254 5.20531,0.70421 0.63103,0.48237 0.96734,3.49919 -0.33288,3.38175 -2.20415,-0.19909 -6.72157,-1.93952 -4.27491,6.24781 l 21.61861,0.3644 -0.33114,-16.07925 c -2.69909,-0.38953 -8.50495,0.33626 -8.33363,1.04589 0.94358,3.90859 -2.59923,4.22934 -5.08229,3.00142 -0.66963,-0.36714 0.47037,-2.20109 0.10252,-2.99309 -0.78827,-1.28418 -3.69368,-0.8065 -8.16329,-0.96312 0,0 -0.70958,-4.82833 -0.42575,-5.05608 2.19333,-0.41775 5.58828,0.77701 5.69185,-2.38338 0.29332,-2.55231 -2.1638,-2.06746 -4.59029,-1.46068 -1.2562,0.31413 -1.57753,-3.06109 -1.19597,-5.67595 l -20.34134,0.0911 0.0473,30.38204 42.43301,-0.1822 0.18922,-30.29094 -22.42279,0";
                var warningTriangle = "m -25,10 11.66727,-22.45064 11.66726,22.45064 z";
                var sphere = "m 0,0 a 10.253048,9.8994951 0 1 1 -4e-5,-0.003";
                var octogon = "m 0,-5 6.63341,-7.14443 11.95156,0 6.46184,7.14443 0,8.97271 -6.46184,6.58185 -11.95156,0 -6.63341,-6.58185 z";
                var auxRect = "m -32,5 0,-13.25825 30.14043,0 0,13.25825 z"

                var margin = {top: 10, right: 120, bottom: 20, left: 140},
                width = window.innerWidth,
                        height = 2 / 3 * window.innerHeight, //850
                        i = 0,
                        duration = 500,
                        depth = width / 4.5,
                        root, metrics;
                var opts = {
                    lines: 20, // The number of lines to draw
                    length: 7, // The length of each line
                    width: 10, // The line thickness
                    radius: 100, // The radius of the inner circle
                    corners: 1, // Corner roundness (0..1)
                    rotate: 0, // The rotation offset
                    color: '#000', // #rgb or #rrggbb
                    speed: 1, // Rounds per second
                    trail: 60, // Afterglow percentage
                    shadow: false, // Whether to render a shadow
                    hwaccel: false, // Whether to use hardware acceleration
                    className: 'spinner', // The CSS class to assign to the spinner
                    zIndex: 2e9, // The z-index (defaults to 2000000000)
                    top: 'auto', // Top position relative to parent in px
                    left: 'auto', // Left position relative to parent in px
                    visibility: true
                };
                var loadingSpinner = new Spinner(opts);
                var tree = d3.layout.tree()
                        .size([height, width]);
                var diagonal = d3.svg.diagonal()
                        .projection(function(d) {
                            return [d.y, d.x];
                        });
                var vis = d3.select("#chart").append("svg")
                        .attr("width", width + margin.right + margin.left)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var colors = ["#E00000", "#CCFFFF"];
                var legend = ["legend", "component", "metric", "requirement"];
                var labels = ["Legend", "Monitored Element", "Metric", "Requirement"];
                var legendleftX = -90;
                var legendleftY = -25;
                var legendRect = vis.selectAll("rect")
                        .data([1], String);
                legendRect.enter().append("rect")
                        .attr("x", legendleftX)
                        .attr("y", legendleftY + 35)
                        .attr("height", 110)
                        .attr("width", 200)
                        .style("stroke", "black")
                        .style("fill", "white");
                var legendCircles = vis.selectAll("circle")
                        .data(legend, String);
                legendCircles.enter().append("path")
                        .attr("d", function(d, i) {
                            if (d == "component") {
                                return "m " + (15 + legendleftX) + "," + (legendleftY + (i * 30) + 40) + " c 1.7265,0.251 5.7035,0.0355 4.8055,2.6145 -0.9305,2.0335 -3.066,3.827 0.214,4.8855 1.9925,0.6435 10.717,1.143 9.7905,-2.5835 -1.1255,-1.2255 -2.5535,-2.4125 -1.2315,-4.0245 2.8935,-0.552 5.8135,-0.9665 8.747,-1.2365 2.779,-0.2555 5.01138,-0.3785 7.80388,-0.3535 0,0 0.0342,-28.8233 0,-28.782 l -42.17988,0 c -0.7375,3.8525 -0.9175,8.9665 1.1535,10.61 3.0355,1.834 7.6995,-3.225 9.5015,0.7885 1.384,3.0825 -0.1075,8.324 -4.242,6.515 -4.9185,-2.1525 -7.189,0.88 -6.7055,6.19 0.1545,1.6955 0.472,3.214 0.701,4.702 3.891,-0.081 7.791,0.114 11.642,0.6745 z";
                            } else if (d == "metric") {
                                return "m " + (8 + legendleftX) + "," + (legendleftY + (i * 30) + 47) + " m 0,-5 0,-13.25825 30.14043,0 0,13.25825 z";
                            } else if (d == "requirement") {
                                return "m " + (8 + legendleftX) + "," + (legendleftY + (i * 30) + 40) + "m 25,0 a 10.253048,9.8994951 0 1 1 -4e-5,-0.003";
                            }
                        })
                        .attr("stroke", "#909090")
                        .attr("fill", function(d) {
                            //                if (d == "component") {
                            //                    return "gray";
                            //                } else if (d == "metric") {
                            return "gray";
                            //                } else if (d == "requirementNotFulfilled") {
                            //                    return "#E00000";
                            //                }
                        });
                legendCircles.append("path")
                        .attr("d", warningTriangle);
                var legendNodes = vis.selectAll("text")
                        .data(legend, String);
                legendNodes.enter().append("text")
                        .attr("dx", function(d, i) {
                            if (d == "legend") {
                                return  legendleftX;
                            } else {
                                return  55 + legendleftX;
                            }
                        })
                        .attr("dy", function(d, i) {
                            if (d == "legend") {
                                return  (legendleftY + (i * 30) + 30);
                            } else if (d == "component") {
                                return  (legendleftY + (i * 30) + 30);
                            } else if (d == "metric") {
                                return (legendleftY + (i * 28) + 45);
                            } else if (d == "requirement") {
                                return (legendleftY + (i * 30) + 45);
                            }
                        })
                        .style("font-size", function(d) {
                            if (d == "legend") {
                                return  "16";
                            } else {
                                return "18";
                            }
                        })
                        .text(function(d, i) {
                            return labels[i];
                        });
                function expandTree(rootNode) {
                    var expanded = [];
                    expanded.push(rootNode);
                    if (rootNode.children) {
                        for (var i = 0; i < rootNode.children.length; i++) {
                            var expandedChildren = expandTree(rootNode.children[i]);
                            for (var j = 0; j < expandedChildren.length; j++) {
                                expanded.push(expandedChildren[j]);
                            }
                        }
                    }

                    return expanded;
                }


                function clean(d, nodeType) {

                    var children = d.children;
                    if (children) {
                        for (var i = children.length - 1; i--; ) {
                            if (children[i].name == nodeType)
                                children[i].remove()
                        }

                        for (var i = children.length - 1; i--; ) {
                            clean(children[i], nodeType);
                        }
                    }
                }


                function updateText(source) {

                    // Compute the new tree layout.
                    var nodes = tree.nodes(root).reverse();
                    //                // Normalize for fixed-depth.
                    nodes.forEach(function(d) {
                        if (d.type == "requirement") {
                            d.y = 0.7 * (d.depth * depth);
                        } else if (!d.type.match(/SERVIC.*|V.*/g) || (d.type == "requirement")) {
                            if (d.parent.children) {
                                var hasComplexChildren;
                                var children = d.parent.children;
                                if (children) {
                                    for (var i = children.length - 1; i--; ) {
                                        if (children[i].type.match(/SERVIC.*|V.*/g)) {
                                            hasComplexChildren = true;
                                            break;
                                        }
                                    }
                                    d.y = 0.85 * d.depth * depth;
                                }
                            }

                        } else {
                            d.y = d.depth * depth;
                        }
                    });
                    // Update the nodes…
                    var node = vis.selectAll("g.node")
                            .data(nodes, function(d) {
                                return d.id || (d.id = ++i);
                            });
                    node.selectAll("text")
                            .text(function(d) {
                                if (d.attention) {
                                    return d.name + ": " + d.actionName;
                                } else if (d.type == "VM") {
                                    return "VM:" + d.name;
                                } else {
                                    return d.name;
                                }
                            });
                    // Enter any new nodes at the parent's previous position.
                    var nodeEnter = node.enter().append("g")
                            .attr("class", "node")
                            .attr("transform", function(d) {
                                return "translate(" + (d.parent.y0) + "," + d.parent.x0 + ")";
                            })
                            .attr("display", function(d) {
                                if (d.name == "SubComponents") {
                                    return "none";
                                } else {
                                    return "yes"
                                }
                                ;
                            })
                            .on("click", function(d) {
                                if (!d.type.match(/SERVIC.*|V.*/g)) {
                                    setSelectedMetricOneLevel(d);
                                }
                                else {
                                    click(d);
                                }
                            })
                            .on("dblclick", setSelectedMetric);
                    nodeEnter.append("path")
                            .attr("d", function(d) {
                                if (d.type == "SERVICE" || d.type == "SERVICE_TOPOLOGY" || d.type == "SERVICE_UNIT") {
                                    return simpleComponentIcon;
                                }

                                else if (d.type == "metric") {
                                    return auxRect;
                                }
                                else if (d.type == "auxiliaryMetric") {
                                    return auxRect;
                                }
                                else if (d.type == "requirement") {
                                    if (d.attention) {
                                        return warningTriangle;
                                    } else {
                                        return sphere;
                                    }
                                    ;
                                }
                                else if (d.name == "SubComponents") {
                                    return complexComponentIcon;
                                }
                            }
                            )
                            .attr("stroke", "black")
                            .attr("stroke-width", 1)
                            .attr("fill", function(d) {
                                if (d.type == "metric") {
                                    return "gray";
                                } else
                                    return "red";
                            });
                    nodeEnter.append("svn:image")
                            .attr("xlink:href", function(d) {
                                if (d.type == "VM") {
                                    return "./vm.png";
                                } else {
                                    return null;
                                }
                            })
                            .attr("width", 30)
                            .attr("height", 30)
                            .attr("dx", -15)
                            .attr("y", -15);
                    // Transition nodes to their new position.
                    var nodeUpdate = node.transition()

                            .duration(function(d) {
                                if (d.type.match(/SERVIC.*|V.*/g)) {
                                    return duration;
                                } else {
                                    return 0;
                                }
                            })
                            .attr("transform", function(d) {
                                if (d.type != "requirement") {
                                    return "translate(" + d.y + "," + d.x + ")";
                                } else {
                                    return "translate(" + d.y + "," + d.x + ")";
                                }
                            })

                    //console.log(node.name)


                    nodeUpdate.select("path")
                            .attr("r", function(d) {
                                return d.value ? 0 : 4.5;
                            })
                            .style("stroke", function(d) {
                                if (d.attention) {
                                    return "#909090";
                                } else {
                                    return "#909090"
                                }
                                ;
                            })
                            .style("fill", function(d) {
                                if (d.type == "metric") {
                                    return "gray";
                                } else {
                                    if (d.attention) {
                                        return "#D13F31";
                                    } else {
                                        if (d.type == "requirement") {
                                            if (d.fulfilled) {
                                                return "#1F7872"
                                            } else {
                                                return "#D13F31";
                                            }

                                        } else {
                                            return "#72B095";
                                        }
                                    }
                                }
                            }
                            );
                    nodeUpdate.select("text")
                            .attr("text-anchor", function(d) {
                                return   d.ip || d.children ? "end" : "start";
                            })
                            .attr("dy", -5)
                            .attr("dx", -15)
                            .style("font-size", function(d) {
                                return (d.type == "metric") ? 14 : 18;
                            })
                            .attr("font-style", function(d) {
                                return d.children ? "normal" : "italic";
                            })
                            .style("fill-opacity", 1)
                            .text(function(d) {
                                if (d.attention) {
                                    return d.name + ": " + d.actionName;
                                } else if (d.type == "VM") {
                                    return "VM:" + d.name;
                                } else {
                                    return d.name;
                                }
                            });
                    // Transition exiting nodes to the parent's new position.
                    var nodeExit = node.exit().transition()
                            .duration(function(d) {
                                if (d.type.match(/SERVIC.*|V.*/g)) {
                                    return duration;
                                } else {
                                    return 0;
                                }
                            })
                            .attr("transform", function(d) {
                                return "translate(" + source.y + "," + source.x + ")";
                            })
                            .remove();
                    nodeExit.select("circle")
                            .attr("r", function(d) {
                                return d.value ? 0 : 8;
                            });
                    nodeExit.select("text")
                            .attr("text-anchor", function(d) {
                                return d.ip || d.children ? "end" : "start";
                            })
                            .attr("dy", -5)
                            .style("font-size", function(d) {
                                return (d.type == "metric") ? 14 : 18;
                            })
                            .attr("font-style", function(d) {
                                return d.children ? "normal" : "italic";
                            })
                            .style("fill-opacity", 1e-6);
                    nodeEnter.append("text")
                            .attr("dx", function(d) {
                                return d.value ? 10 : 5;
                            })
                            .attr("dy", function(d) {
                                return d.value ? 0 : 10;
                            })
                            .style("font-size", function(d) {
                                return (d.type == "metric") ? 14 : 18;
                            })

                            .attr("font-style", function(d) {
                                return d.children ? "normal" : "italic";
                            })
                            .text(function(d) {
                                if (d.attention) {
                                    return d.name + ": " + d.actionName;
                                } else if (d.type == "VM") {
                                    return "VM:" + d.name;
                                } else {
                                    return d.name;
                                }
                            });
                    // Update the links…
                    var link = vis.selectAll("path.link")
                            .data([], function(d) {
                                return d.target.id;
                            });
                    link.exit().remove();
                    link = vis.selectAll("path.link")
                            .data(tree.links(nodes), function(d) {
                                return d.target.id;
                            });
                    // Enter any new links at the parent's previous position.
                    link.enter().insert("path", "g")
                            .attr("class", "link")
                            .attr("d", function(d) {
                                var o = {x: source.x, y: source.y};
                                return diagonal({source: o, target: o});
                            })
                            .style("stroke-dasharray", function(d) {
                                if (d.target.type == "metric") {
                                    return "0";
                                }
                                else if (d.target.type == "requirement") {
                                    return "3.3";
                                }
                                else if (d.target.type == "auxiliaryMetric") {
                                    return "3.3";
                                }
                                else {
                                    return "1";
                                }
                            })
                            .style("stroke", function(d) {
                                if (d.target.type == "requirement") {
                                    if (d.target.attention) {
                                        return "#E00000";
                                    }
                                    else {
                                        return "#00E096";
                                    }
                                } else {
                                    return "#ccc";
                                }
                            })
                            .style("stroke-width", function(d) {
                                if (d.target.type == "requirement") {
                                    return "1";
                                }
                                else if (d.target.type == "auxiliaryMetric") {
                                    return "0.5";
                                }
                                else {
                                    return "1";
                                }
                            })
                            ;
                    // Transition links to their new position.
                    link.transition()
                            .duration(0)
                            .attr("d", diagonal);
                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition()
                            .duration(0)
                            .attr("d", function(d) {
                                var o = {x: source.x, y: source.y};
                                return diagonal({source: o, target: o});
                            })
                            .remove();
                    // Stash the old positions for transition.
                    nodes.forEach(function(d) {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                }

                function getMaxDepth(node, curentDepth) {
                    curentDepth++;
                    var maxDepth = curentDepth;
                    if (node.children) {
                        node.children.forEach(function(d) {
                            var maxChildDepth = getMaxDepth(d, curentDepth)
                            if (maxDepth < maxChildDepth) {
                                maxDepth = maxChildDepth;
                            }
                        });
                    }
                    return maxDepth;
                }

                function update(source) {

                    // Compute the new tree layout.
                    var nodes = tree.nodes(root).reverse();
                    var levels = getMaxDepth(source, 0);
                    depth = width / (levels + 1);
                    // Normalize for fixed-depth.
                    nodes.forEach(function(d) {
                        if (d.type == "requirement") {
                            d.y = 0.9 * (d.depth * depth);
                        } else if (d.type == "strategy") {
                            d.y = d.parent.depth;
                        } else {
                            d.y = (d.depth * depth);
                        }
                    });
                    // Update the nodes…
                    var node = vis.selectAll("g.node")
                            .data(nodes, function(d) {
                                return d.id || (d.id = ++i);
                            });
                    // Enter any new nodes at the parent's previous position.
                    var nodeEnter = node.enter().append("g")
                            .attr("class", "node")
                            .attr("transform", function(d) {
                                //                    if (d.type != "requirement") {
                                return "translate(" + source.y + "," + source.x + ")";
                                //                    }
                                //                    else {
                                //                        return "translate(" + (d.parent.y0) + "," + d.parent.x0 + ")";
                                //                    }
                            })
                            .attr("display", function(d) {
                                if (d.name == "SubComponents") {
                                    return "none";
                                } else {
                                    return "yes"
                                }
                            })

                            .on("click", function(d) {

                                //As a major hack, the form for the context menu appearing on click is created on demand
                                if (d.type == "Condition") {
                                    tooltip.html(createHTMLManagementButtonText("Remove Condition", "Condition", "removeFromStructure", d.id));
                                } else if (d.type == "Requirement") {
                                    tooltip.html(createHTMLManagementButtonText("Add Condition", "Condition", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Remove Requirement", "Requirement", "removeFromStructure", d.id));
                                } else if (d.type == "SERVICE") {
                                    tooltip.html(createHTMLManagementButtonText("Add Service Topology", "Topology", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Add Requirements Block", "Requirements", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Add Strategy", "Strategy", "addToStructure", d.id));
                                } else if (d.type == "SERVICE_TOPOLOGY") {
                                    tooltip.html(createHTMLManagementButtonText("Add Service Unit", "Unit", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Add Requirements Block", "Requirements", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Add Strategy", "Strategy", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Remove Service Topology", "Topology", "removeFromStructure", d.id));
                                } else if (d.type == "SERVICE_UNIT") {
                                    tooltip.html(createHTMLManagementButtonText("Add Requirements Block", "Requirements", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Add Strategy", "Strategy", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Remove Service Unit", "Unit", "removeFromStructure", d.id));
                                } else if (d.type == "RequirementsBlock") {
                                    tooltip.html(createHTMLManagementButtonText("Add Requirement", "Requirement", "addToStructure", d.id)
                                            + '\n' + createHTMLManagementButtonText("Remove Requirements Block", "Requirements", "removeFromStructure", d.id));
                                } else if (d.type == "Strategy") {
                                    tooltip.html(createHTMLManagementButtonText("Remove Strategy", "Strategy", "removeFromStructure", d.id));
                                }
                                tooltip.style("visibility", "visible");
                                return tooltip.style("top", (event.pageY - 10) + "px").style("left", (event.pageX + 10) + "px");
                            })
//                        .on("mousemove", function() {
//                            return tooltip.style("top", (event.pageY - 10) + "px").style("left", (event.pageX + 10) + "px");
//                        })
                            .on("dblclick", function(d) {
                                return tooltip.style("visibility", "hidden");
                            })
                            ;
                    nodeEnter.append("path")
                            .attr("d", function(d) {
                                if (d.type == "SERVICE" || d.type == "SERVICE_TOPOLOGY" || d.type == "SERVICE_UNIT") {
                                    return simpleComponentIcon;
                                }

                                else if (d.type == "metric") {
                                    return auxRect;
                                }
                                else if (d.type == "auxiliaryMetric") {
                                    return auxRect;
                                }
                                else if (d.type == "requirement") {
                                    if (d.attention) {
                                        return warningTriangle;
                                    } else {
                                        return sphere;
                                    }
                                    ;
                                }
                                else if (d.name == "SubComponents") {
                                    return complexComponentIcon;
                                }
                            }
                            )
                            .attr("stroke", "black")
                            .attr("stroke-width", 1)
                            .attr("fill", function(d) {
                                if (d.type == "metric") {
                                    return "red";
                                }
                                else {
                                    return "orange";
                                }
                            });
                    nodeEnter.append("svn:image")
                            .attr("xlink:href", function(d) {
                                if (d.type == "VM") {
                                    return "./vm.png";
                                } else {
                                    return null;
                                }
                            })
                            .attr("width", 30)
                            .attr("height", 30)
                            .attr("dx", -15)
                            .attr("y", -15);
                    nodeEnter.append("text")
                            .attr("dx", function(d) {
                                return d.value ? 40 : -8;
                            })
                            .attr("y", function(d) {
                                return d.value ? -10 : -5;
                            })
                            .attr("text-anchor", function(d) {
                                return  d.ip || d.children ? "end" : "start";
                            })
                            .style("font-size", function(d) {
                                return (d.type == "metric") ? 14 : 19;
                            })
                            .attr("font-style", function(d) {
                                return d.children ? "normal" : "italic";
                            })
                            .style("fill-opacity", 1e-6)
                            .text(function(d) {
                                if (d.attention) {
                                    return d.name + ": " + d.actionName;
                                } else if (d.type == "VM") {
                                    return "VM:" + d.name;
                                } else {
                                    return d.name;
                                }
                            });
                    // Transition nodes to their new position.
                    var nodeUpdate = node.transition()

                            .duration(duration)
                            .attr("transform", function(d) {
                                //                    if (d.type != "requirement") {
                                return "translate(" + d.y + "," + d.x + ")";
                                //                    } else {
                                //                        return "translate(" + d.y + "," + d.x + ")";
                                //                    }
                            })
                    //.attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
                    //console.log(node.name)

                    nodeUpdate.select("circle")
                            .attr("r", function(d) {
                                return d.value ? 0 : 8;
                            })
                            .style("stroke", function(d) {
                                if (d.attention) {
                                    return "#909090";
                                } else {
                                    return "#909090"
                                }
                                ;
                            })
                            .style("fill", function(d) {
                                if (d.attention) {
                                    return "#E00000";
                                } else {
                                    return "#CCFFFF";
                                }
                            });
                    nodeUpdate.select("rect")
                            .attr("r", function(d) {
                                return d.value ? 0 : 4.5;
                            })
                            .style("stroke", function(d) {
                                if (d.attention) {
                                    return "#909090";
                                } else {
                                    return "#909090"
                                }
                                ;
                            })
                            .style("fill", function(d) {
                                if (d.attention) {
                                    return "#FF6666";
                                } else {
                                    return "#CCFFFF";
                                }
                            });
                    nodeUpdate.select("text")
                            .attr("text-anchor", function(d) {
                                return   d.ip || d.children ? "end" : "start";
                            })
                            .attr("dy", -5)
                            .attr("dx", -15)
                            .style("font-size", function(d) {
                                return (d.type == "metric") ? 14 : 19;
                            })
                            .attr("font-style", function(d) {
                                return d.children ? "normal" : "italic";
                            })
                            .style("fill-opacity", 1);
                    // Transition exiting nodes to the parent's new position.
                    var nodeExit = node.exit().transition()
                            .duration(duration)
                            .attr("transform", function(d) {
                                return "translate(" + source.y + "," + source.x + ")";
                            })
                            .remove();
                    nodeExit.select("circle")
                            .attr("r", function(d) {
                                return d.value ? 0 : 8;
                            });
                    nodeExit.select("text")
                            .attr("text-anchor", function(d) {
                                return   d.ip || d.children ? "end" : "start";
                            })
                            .attr("dy", -5)
                            .style("font-size", function(d) {
                                return (d.type == "metric") ? 14 : 19;
                            })
                            .attr("font-style", function(d) {
                                return d.children ? "normal" : "italic";
                            })
                            .style("fill-opacity", 1e-6);
                    // Update the links…
                    var link = vis.selectAll("path.link")
                            .data([], function(d) {
                                return d.target.id;
                            });
                    link.exit().remove();
                    link = vis.selectAll("path.link")
                            .data(tree.links(nodes), function(d) {
                                return d.target.id;
                            });
                    //TODO: test if works without this.
                    // Enter any new links at the parent's previous position.
                    link.enter().insert("path", "g")
                            .attr("class", "link")
                            .attr("d", function(d) {
                                if (d.target.type == "metric") {
                                    var o = {x: source.x, y: source.y};
                                    return diagonal({source: o, target: o});
                                } else {
                                    var o = {x: source.x, y: source.y};
                                    return diagonal({source: o, target: o});
                                }
                            })
                            .style("stroke-dasharray", function(d) {
                                if (d.target.type == "metric") {
                                    return "0";
                                }
                                else if (d.target.type == "requirement") {
                                    return "3.3";
                                }
                                else if (d.target.type == "auxiliaryMetric") {
                                    return "3.3";
                                }
                                else {
                                    return "1";
                                }
                            })
                            .style("stroke", function(d) {
                                if (d.target.type == "requirement") {
                                    if (d.target.attention) {
                                        return "#E00000";
                                    }
                                    else {
                                        return "#00E096";
                                    }
                                } else {
                                    return "#ccc";
                                }
                            })
                            .style("stroke-width", function(d) {
                                if (d.target.type == "requirement") {
                                    return "1";
                                }
                                else if (d.target.type == "auxiliaryMetric") {
                                    return "0.5";
                                }
                                else {
                                    return "1";
                                }
                            })
                            ;
                    // Transition links to their new position.
                    link.transition()
                            .duration(duration)
                            .attr("d", diagonal);
                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition()
                            .duration(duration)
                            .attr("d", function(d) {
                                var o = {x: source.x, y: source.y};
                                return diagonal({source: o, target: o});
                            })
                            .remove();
                    // Stash the old positions for transition.
                    nodes.forEach(function(d) {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                }



                function showContent(d, show) {
                    if (!show && d.children) {
                        d._children = d.children;
                        d.children = null;
                        update(d);
                    } else if (!d.children) {
                        d.children = d._children;
                        d._children = null;
                        update(d);
                    }

                }


                function refreshMonitoringData() {

                    reqMonitoringDataObject = null;
                    if (window.XMLHttpRequest) {
                        reqMonitoringDataObject = new XMLHttpRequest();
                    } else {
                        reqMonitoringDataObject = new ActiveXObject("Microsoft.XMLHTTP");
                    }

                    reqMonitoringDataObject.onreadystatechange = processMonitoringDataResponse;
                    reqMonitoringDataObject.open("GET", "./api/requirementsManagement/json/requirements", true);
                    reqMonitoringDataObject.send(null);
                }

                function processMonitoringDataResponse() {
                    if (reqMonitoringDataObject.readyState == 4) {


                        new_root = JSON.parse(reqMonitoringDataObject.responseText);
                        //setTimeout(refreshMonitoringData, 5000);

                        if (new_root.children) {
                            loadingSpinner.stop();
                            d3.select("#A").remove();
                            //                        setTimeout(refreshMonitoringData, 1000);
                        }

                        //if we have root that changed and is not metric, update its tree
                        if ((root == null) || (root.type != "metric" && root.name != new_root.name)) {
                            root = new_root;
                            update(root);
                            //                        updateTextOnNode(root, root, change);
                        } else {
                            var change = -1;
                            updateTextOnNode(root, new_root, change);
                            if (change == -1) {
                                updateText(root);
                            } else {
                                update(new_root);
                            }
                        }
                    }
                }


                function drawSpinner(spinnerContainer) {
                    var target = document.getElementById(spinnerContainer);
                    //target.style.display = "block";
                    loadingSpinner.spin(target);
                }

//            drawSpinner('A');
//
//            refreshMetricsCompositionRules();
                refreshMonitoringData();
//            var tooltip = d3.select("body")
//                    .append("div");
//                    .style("position", "absolute")
//                    .style("z-index", "10")
//                    .style("visibility", "hidden")
//                    .text("a simple tooltip");

                var body = d3.select("body");
                var tooltip = body.append("div");
                tooltip.style("position", "absolute")
                        .style("z-index", "10")
                        .style("visibility", "hidden");
                var strategyFormDiv = body.append("div");
//            strategyFormDiv.style("position", "absolute")
//                    .style("z-index", "10")
//                    .style("background", "red")
//                    .style("width:", "500px")
//                    .style("height:", "500px")
//                    .style("visibility", "hidden");
//            strategyFormDiv.html("<form action=\"javascript:void(0);\" id=\"AddStrategyForm\" onsubmit=\"return processExecutingCommand(this)\">\
//                Strategy: \
//            <select name=\"strategyOptionSelect\" id=\"strategyOptionSelect\" form=\"AddStrategyForm\" >\
//                <option value=\"manageStructure\" selected>Manage Structure</option>\
//                <option value=\"ssss\" selected>Manage sss</option>\
//                </select>\
//                <input type=\"text\" name=\"data\" id=\"data\" hidden/>\
//                <input type=\"submit\">\
//            </form>");
                //very complicated hack
                function removeFromStructure(f) {

                    //i get the tree nodes
                    var nodes = tree.nodes(root).reverse();
                    //from the submitted form that called this function, i get only node id == index, 
                    ////and thus, need to get it from nodes list
                    var selectedNode = nodes[f.d.value - 1];
                    var type = f.type.value;
                    //create node trace, to know from where to remove the node
                    var data = '{ "command" : "remove", "type": "' + type + '","trace" : ' + createNodeTrace(selectedNode) + '}';
                    console.log(data);
                    var url = "./api/requirementsManagement/management/json/requirements";
                    createStructureManagementRestRequest("DELETE", "application/json", url, data);


                }

                //very complicated hack
                function addToStructure(f) {

                    //i get the tree nodes
                    var nodes = tree.nodes(root).reverse();
                    //from the submitted form that called this function, i get only node id == index, 
                    ////and thus, need to get it from nodes list
                    var selectedNode = nodes[f.d.value - 1];
                    var type = f.type.value;
                    currentExecutingOperation = "ADD";
                    currentExecutingOperationType = type;
                    var currentForm;
                    var currentFormDiv;
                    switch (type) {
                        case "Strategy":
                            {
                                currentForm = document.getElementById("AddStrategyForm");
                                currentFormDiv = document.getElementById("AddStrategyDiv");
//                            currentFormDiv = strategyFormDiv;
                            }
                            break;
                        case "Topology":
                            {
                                currentForm = document.getElementById("AddStructureElementForm");
                                currentFormDiv = document.getElementById("AddStructureElementDiv");
                            }
                            break;
                        case "Unit":
                            {
                                currentForm = document.getElementById("AddStructureElementForm");
                                currentFormDiv = document.getElementById("AddStructureElementDiv");
                            }
                            break;
                        case "Requirements":
                            {
                                currentForm = document.getElementById("AddStructureElementForm");
                                currentFormDiv = document.getElementById("AddStructureElementDiv");
                            }
                            break;
                        case "Requirement": //here we need to continue to get the targeted Requirements block
                            {

                            }
                            break;
                        case "Condition": //here we also need to get the requirement
                            {
                                currentForm = document.getElementById("AddConditionForm");
                                currentFormDiv = document.getElementById("AddConditionDiv");
                            }
                            break;
                    }

                    currentForm.data.value = '"trace" : ' + createNodeTrace(selectedNode) + '';
//                currentFormDiv.style("visibility", "visible");
                    currentFormDiv.hidden = false;
//                    currentFormDiv.style("top", (window.innerHeight / 2 - 10 + "px")).style("left", (window.innerWidth / 2 - 10 + "px"));

                    //create node trace, to know from where to remove the node
//                    var data = '{ "command" : "add", "type": "' + type + '", "trace" : ' + createNodeTrace(selectedNode) + '}';
//                    console.log(data);

//                    var url = "./api/requirementsManagement/management/json/requirements";
//                    createStructureManagementRestRequest("PUT", "application/json", url, data);

                }

                function processExecutingCommand(f) {

                    var url = "./api/requirementsManagement/management/json/requirements";
                    var data = '"command" : "ADD", "type": "' + currentExecutingOperationType + '",' + f.data.value;
                    switch (currentExecutingOperation) {
                        case "ADD":
                            switch (currentExecutingOperationType) {
                                case "Strategy":
                                    {
                                        document.getElementById("AddStrategyDiv").hidden = true;
                                        var strategyOptionSelect = document.getElementById("strategyOptionSelect");
                                        data = '{' + data + ', "meta" : { "strategy":"' + strategyOptionSelect.options[strategyOptionSelect.selectedIndex].text + '" } ' + '}';
                                        createStructureManagementRestRequest("PUT", "application/json", url, data);
                                    }
                                    break;
                                case "Topology":
                                    {
                                        document.getElementById("AddStructureElementDiv").hidden = true;
                                        var strategyOptionSelect = document.getElementById("AddStructureElementForm").elementName.value;
                                        data = '{' + data + ', "meta" : { "name":"' + f.elementName.value + '" } ' + '}';
                                        createStructureManagementRestRequest("PUT", "application/json", url, data);
                                    }
                                    break;
                                case "Unit":
                                    {
                                        document.getElementById("AddStructureElementDiv").hidden = true;
                                        var strategyOptionSelect = document.getElementById("AddStructureElementForm").elementName.value;
                                        data = '{' + data + ', "meta" : { "name":"' + f.elementName.value + '" } ' + '}';
                                        createStructureManagementRestRequest("PUT", "application/json", url, data);
                                    }
                                    break;
                                case "Requirements":
                                    {
                                        document.getElementById("AddStructureElementDiv").hidden = true;
                                        var strategyOptionSelect = document.getElementById("AddStructureElementForm").elementName.value;
                                        data = '{' + data + ', "meta" : { "name":"' + f.elementName.value + '" } ' + '}';
                                        createStructureManagementRestRequest("PUT", "application/json", url, data);
                                    }
                                    break;
                                case "Requirement": //here we need to continue to get the targeted Requirements block
                                    {
                                        document.getElementById("AddRequirementDiv").hidden = true;
                                        var metricTypeSelect = document.getElementById("metricTypeSelect");

                                        var metricsSelect = document.getElementById("requirementMetricsSelect");
                                        var selectedMetric = metricsSelect.options[metricsSelect.selectedIndex];
                                        var metricData = '{ "name":"' + selectedMetric.text + '"'
                                                + ', "unit": "' + selectedMetric.getAttribute("unit") + '", "type":"' + selectedMetric.getAttribute("type") + '"}';
                                        data = '{' + data + ', "meta" : { "metric":' + metricData + ' } ' + '}';
                                        createStructureManagementRestRequest("PUT", "application/json", url, data);
                                    }
                                    break;
                                case "Condition": //here we also need to get the requirement
                                    {

                                        document.getElementById("AddConditionDiv").hidden = true;
                                        var conditionTypeSelect = document.getElementById("conditionTypeSelect");
                                        
                                        var selectedConditionType = conditionTypeSelect.options[conditionTypeSelect.selectedIndex];
                                        var conditionData = '{ "type":"' + selectedConditionType.text + '"'
                                                + ', "value": "' + f.conditionValue.value + '"}';
                                        data = '{' + data + ', "meta" : { "condition":' + conditionData + ' } ' + '}';
                                        createStructureManagementRestRequest("PUT", "application/json", url, data);
                                    }
                                    break;
                            }
                            break;
                        case "DELETE":
                            break;
                    }
                    currentExecutingOperationType = type;
                    data = '{' + data + '}';
                    console.log(data);
                }



                //create JSON node trace as JSON array, to know from where to remove the node
                function createNodeTrace(source) {
                    var parents = [];
                    var currentParent = source;
                    while (currentParent) {
                        var parentJSONDescription = '{"name" : "' + currentParent.realName + '", "type" : "' + currentParent.type + '"}';
                        parents.push(parentJSONDescription);
                        currentParent = currentParent.parent;
                    }

                    parents = parents.reverse();
                    var completeJSONDescription = "[";
                    for (var x in parents) {
                        completeJSONDescription += parents[x] + ",";
                    }

                    completeJSONDescription = completeJSONDescription.slice(0, -1);

                    return completeJSONDescription + "]";
                }


                function createStructureManagementRestRequest(restMethod, contentType, url, data) {
                    var req = createRequest(); // defined above
                    //
                    req.open(restMethod, url, true);
                    req.setRequestHeader("Content-Type",
                            contentType);
                    req.send(data);
// Create the callback:
                    req.onreadystatechange = function() {
                        if (req.readyState != 4)
                            return; // Not there yet
                        if (req.status != 200) {
                            console.log(req.responseText);
                            return;
                        }

                        var resp = req.responseText;
                        console.log(resp);
                        //currently just reload page on post. in future, reload only D3_JS svg
                        location.reload();
                    }
                }
                //creates http request
                function createRequest() {
                    var result = null;
                    if (window.XMLHttpRequest) {
                        // FireFox, Safari, etc.
                        result = new XMLHttpRequest();
                        if (typeof result.overrideMimeType != 'undefined') {
                            result.overrideMimeType('text/xml'); // Or anything else
                        }
                    }
                    else if (window.ActiveXObject) {
                        // MSIE
                        result = new ActiveXObject("Microsoft.XMLHTTP");
                    }
                    else {
                        // No known mechanism -- consider aborting the application
                    }
                    return result;
                }


                function createHTMLManagementButtonText(name, type, functionToCall, param) {
                    return '<form  action="#" onsubmit="return ' + functionToCall + '(this)" id="formFor_' + name + '">' +
                            '<input type="submit" value="' + name + '" ><br/>\<input type="text" id="d" value= "' + param + '" hidden/>' +
                            '<input type="text" id="type" value= "' + type + '" hidden/>' +
                            '</form>';
                }

                function automaticallyPopulateMetricsList(f) {
                    var metricTypeSelect = document.getElementById("metricTypeSelect");


                    var selectedMetricType = metricTypeSelect.options[metricTypeSelect.selectedIndex].text;


                    if (window.XMLHttpRequest) {
                        getMetricsReq = new XMLHttpRequest();
                    } else {
                        getMetricsReq = new ActiveXObject("Microsoft.XMLHTTP");
                    }

                    getMetricsReq.onreadystatechange = populateMetricsSelectList;

                    switch (selectedMetricType) {
                        case "COST":
                            getMetricsReq.open("GET", "./api/requirementsManagement/json/costmetrics", true);
                            break;
                        case "QUALITY":
                            getMetricsReq.open("GET", "./api/requirementsManagement/json/qualitymetrics", true);
                            break;
                        case "RESOURCE":
                            getMetricsReq.open("GET", "./api/requirementsManagement/json/resourcemetrics", true);
                            break;

                    }

                    getMetricsReq.send(null);


                }

                function populateMetricsSelectList() {

                    if (getMetricsReq.readyState == 4) {

                        var metricsSelect = document.getElementById("requirementMetricsSelect");

                        var metrics = JSON.parse(getMetricsReq.responseText);

                        //clear former metrics from list

                        for (var index in metricsSelect.options)
                        {
                            metricsSelect.remove(index);
                        }

                        metrics.forEach(function(metric) {

                            var option = document.createElement("option");
                            option.text = metric.name;
                            option.value = metric.name;
                            option.setAttribute("unit", metric.unit);
                            option.setAttribute("type", metric.type);
                            metricsSelect.add(option);
                        });
                    }

                }


                var metricTypeSelect = document.getElementById("metricTypeSelect");
                metricTypeSelect.onchange = automaticallyPopulateMetricsList;
//                metricTypeSelect.addEventListener('change', automaticallyPopulateMetricsList(this);, false);


        </script>

    </body>
</html>


